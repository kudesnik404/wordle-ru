{"ast":null,"code":"const {\n  CR,\n  WS,\n  ES,\n  NL,\n  FORMAT,\n  STRING,\n  EMPTY_DATA_MSG,\n  EMPTY_DATA_EXCEPTION,\n  NOT_A_STRING_MSG,\n  INVALID_DATA_EXCEPTION,\n  FILE_NOT_FOUND_EXCEPTION,\n  NOT_VALID_ARG_MSG,\n  INVALID_ARGUMENT_EXCEPTION\n} = require(\"./constants\");\n\nconst getTrimmedValue = function (line, startPoints, index) {\n  return line.substring(startPoints[index], startPoints[index + 1]).trim();\n};\n\nconst getObject = function (line, headers, startPoints) {\n  return headers.reduce(function (acc, currentElement, index) {\n    let trimmedValue = getTrimmedValue(line, startPoints, index);\n\n    if (trimmedValue === \"null\") {\n      trimmedValue = null;\n    }\n\n    acc[currentElement] = trimmedValue;\n    return acc;\n  }, {});\n};\n\nconst formatDataInArray = function (data, startPoints, headers) {\n  let finalResult = [];\n  data.forEach(line => {\n    if (line === ES) {\n      return;\n    }\n\n    finalResult.push(getObject(line, headers, startPoints));\n  });\n  return finalResult;\n};\n\nconst pushHeader = function (isWS, isNextNotWS, isLastChar, headers, header) {\n  if (isWS && isNextNotWS || isLastChar) {\n    if (header !== ES) {\n      headers.push(header);\n      header = ES;\n    }\n  }\n\n  return {\n    headers,\n    header\n  };\n};\n\nconst addCharToHeader = function (char, header) {\n  if (char !== WS && char !== CR && char !== NL) {\n    header += char;\n  }\n\n  return header;\n};\n\nconst getHeaders = function (headersLine) {\n  const splittedHeaderLine = headersLine.split(ES);\n  const headerLineLength = headersLine.length;\n  let headers = [];\n  let header = ES;\n  splittedHeaderLine.forEach((char, index) => {\n    const isWS = char === WS;\n    const nextChar = splittedHeaderLine[index + 1];\n    const isNextNotWS = nextChar !== WS;\n    const isLastChar = index === headerLineLength - 1;\n    header = addCharToHeader(char, header);\n    const head = pushHeader(isWS, isNextNotWS, isLastChar, headers, header);\n    headers = head.headers;\n    header = head.header;\n  });\n  return headers;\n};\n\nconst pushStartPoint = function (char, nextChar, startPoints, index) {\n  if (char === WS && nextChar !== WS) startPoints.push(index + 1);\n  return startPoints;\n};\n\nconst getStartPoints = function (splittedHeaderLine) {\n  let startPoints = [0];\n  splittedHeaderLine.forEach((char, index) => {\n    const nextChar = splittedHeaderLine[index + 1];\n    startPoints = pushStartPoint(char, nextChar, startPoints, index);\n  });\n  return startPoints;\n};\n\nconst readFile = function (filePath, fs) {\n  if (fs.existsSync(filePath)) return fs.readFileSync(filePath, FORMAT).split(NL);\n  console.error(`ERROR -->> ${filePath} is not a valid path.`);\n  throw Error(FILE_NOT_FOUND_EXCEPTION);\n};\n\nconst readData = function (data) {\n  if (typeof data === STRING) {\n    if (data.length) return data.split(NL);\n    console.error(EMPTY_DATA_MSG);\n    throw Error(EMPTY_DATA_EXCEPTION);\n  }\n\n  console.error(NOT_A_STRING_MSG);\n  throw Error(INVALID_DATA_EXCEPTION);\n};\n\nconst getData = function (params, fs) {\n  if (params.filePath == null && params.data == null) {\n    console.error(NOT_VALID_ARG_MSG);\n    throw Error(INVALID_ARGUMENT_EXCEPTION);\n  }\n\n  if (params.filePath || params.filePath === ES) {\n    return readFile(params.filePath, fs);\n  } else {\n    return readData(params.data);\n  }\n};\n\nconst getRequiredData = function (params, data) {\n  let dataWithoutHeaders = data.slice(1);\n\n  if (params.noOfRecords || params.noOfRecords === 0) {\n    dataWithoutHeaders = dataWithoutHeaders.slice(0, params.noOfRecords);\n  }\n\n  return dataWithoutHeaders;\n};\n\nmodule.exports = {\n  getStartPoints,\n  pushStartPoint,\n  getHeaders,\n  addCharToHeader,\n  pushHeader,\n  formatDataInArray,\n  getObject,\n  getTrimmedValue,\n  readFile,\n  readData,\n  getData,\n  getRequiredData\n};","map":{"version":3,"names":["CR","WS","ES","NL","FORMAT","STRING","EMPTY_DATA_MSG","EMPTY_DATA_EXCEPTION","NOT_A_STRING_MSG","INVALID_DATA_EXCEPTION","FILE_NOT_FOUND_EXCEPTION","NOT_VALID_ARG_MSG","INVALID_ARGUMENT_EXCEPTION","require","getTrimmedValue","line","startPoints","index","substring","trim","getObject","headers","reduce","acc","currentElement","trimmedValue","formatDataInArray","data","finalResult","forEach","push","pushHeader","isWS","isNextNotWS","isLastChar","header","addCharToHeader","char","getHeaders","headersLine","splittedHeaderLine","split","headerLineLength","length","nextChar","head","pushStartPoint","getStartPoints","readFile","filePath","fs","existsSync","readFileSync","console","error","Error","readData","getData","params","getRequiredData","dataWithoutHeaders","slice","noOfRecords","module","exports"],"sources":["/Users/kudesnik/Desktop/Projects/wordle-ru/node_modules/txt-file-to-json/src/lib.js"],"sourcesContent":["const {\n    CR,\n    WS,\n    ES,\n    NL,\n    FORMAT,\n    STRING,\n    EMPTY_DATA_MSG,\n    EMPTY_DATA_EXCEPTION,\n    NOT_A_STRING_MSG,\n    INVALID_DATA_EXCEPTION,\n    FILE_NOT_FOUND_EXCEPTION,\n    NOT_VALID_ARG_MSG,\n    INVALID_ARGUMENT_EXCEPTION\n} = require(\"./constants\");\n\nconst getTrimmedValue = function (line, startPoints, index) {\n    return line.substring(startPoints[index], startPoints[index + 1]).trim();\n};\n\nconst getObject = function (line, headers, startPoints) {\n    return headers.reduce(function (acc, currentElement, index) {\n        let trimmedValue = getTrimmedValue(line, startPoints, index);\n\n        if (trimmedValue === \"null\") {\n            trimmedValue = null;\n        }\n        acc[currentElement] = trimmedValue;\n        return acc;\n    }, {});\n};\n\nconst formatDataInArray = function (data, startPoints, headers) {\n    let finalResult = [];\n\n    data.forEach(line => {\n        if (line === ES) {\n            return;\n        }\n        finalResult.push(getObject(line, headers, startPoints));\n    });\n    return finalResult;\n};\n\nconst pushHeader = function (isWS, isNextNotWS, isLastChar, headers, header) {\n    if ((isWS && isNextNotWS) || isLastChar) {\n        if (header !== ES) {\n            headers.push(header);\n            header = ES;\n        }\n    }\n    return {headers, header};\n};\n\nconst addCharToHeader = function (char, header) {\n    if (char !== WS && char !== CR && char !== NL) {\n        header += char;\n    }\n    return header;\n};\n\nconst getHeaders = function (headersLine) {\n    const splittedHeaderLine = headersLine.split(ES);\n    const headerLineLength = headersLine.length;\n    let headers = [];\n    let header = ES;\n\n    splittedHeaderLine.forEach((char, index) => {\n        const isWS = char === WS;\n        const nextChar = splittedHeaderLine[index + 1];\n        const isNextNotWS = nextChar !== WS;\n        const isLastChar = index === headerLineLength - 1;\n\n        header = addCharToHeader(char, header);\n        const head = pushHeader(isWS, isNextNotWS, isLastChar, headers, header);\n        headers = head.headers;\n        header = head.header;\n    });\n    return headers;\n};\n\nconst pushStartPoint = function (char, nextChar, startPoints, index) {\n    if (char === WS && nextChar !== WS) startPoints.push(index + 1);\n    return startPoints;\n};\n\nconst getStartPoints = function (splittedHeaderLine) {\n    let startPoints = [0];\n    splittedHeaderLine.forEach((char, index) => {\n        const nextChar = splittedHeaderLine[index + 1];\n        startPoints = pushStartPoint(char, nextChar, startPoints, index);\n    });\n    return startPoints;\n};\n\nconst readFile = function (filePath, fs) {\n    if (fs.existsSync(filePath))\n        return fs.readFileSync(filePath, FORMAT).split(NL);\n    console.error(`ERROR -->> ${filePath} is not a valid path.`);\n    throw Error(FILE_NOT_FOUND_EXCEPTION);\n};\n\nconst readData = function (data) {\n    if (typeof data === STRING) {\n        if (data.length)\n            return data.split(NL);\n        console.error(EMPTY_DATA_MSG);\n        throw Error(EMPTY_DATA_EXCEPTION);\n    }\n    console.error(NOT_A_STRING_MSG);\n    throw Error(INVALID_DATA_EXCEPTION);\n};\n\nconst getData = function (params, fs) {\n    if (params.filePath == null && params.data == null) {\n        console.error(NOT_VALID_ARG_MSG);\n        throw Error(INVALID_ARGUMENT_EXCEPTION);\n    }\n    if (params.filePath || params.filePath === ES) {\n        return readFile(params.filePath, fs);\n    } else {\n        return readData(params.data);\n    }\n};\n\nconst getRequiredData = function (params, data) {\n    let dataWithoutHeaders = data.slice(1);\n    if (params.noOfRecords || params.noOfRecords === 0) {\n        dataWithoutHeaders = dataWithoutHeaders.slice(0,params.noOfRecords);\n    }\n    return dataWithoutHeaders;\n};\n\nmodule.exports = {\n    getStartPoints,\n    pushStartPoint,\n    getHeaders,\n    addCharToHeader,\n    pushHeader,\n    formatDataInArray,\n    getObject,\n    getTrimmedValue,\n    readFile,\n    readData,\n    getData,\n    getRequiredData\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}